<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[docker-ce安装 与docker镜像（Centos7)]]></title>
    <url>%2F2018%2F12%2F12%2Fdocker-ce%E5%AE%89%E8%A3%85-%E4%B8%8Edocker%E9%95%9C%E5%83%8F%EF%BC%88Centos7%2F</url>
    <content type="text"><![CDATA[安装docker-ce（设置清华大学镜像站为镜像源) 在centos7 yum仓库 的extras仓库中自带了docker源,都是docker 1.13版本，不建议使用老版本docker.清华大学在镜像站中给docker做了镜像在此目录下找到docker的repo文件我们可以自己建一个docker镜像源仓库，首先要把该repo文件下载到/etc/yum.repos.d 中下载后打开docker-ce.repo文件，文件中指向的地址是docker官方站点，这个下载速度是很慢的，因此还要修改下载路径仍然选择清华大学镜像站，来到这个目录下，选择稳定版可以看到这里有最新版本18.06选择复制链接中的linux父目录https://mirrors.tuna.tsinghua.edu.cn/docker-ce/然后全局替换docker-ce.repo中的官方地址的linux的父目录用vim打开，在末行模式下进行替换可以看到替换成功yum repolist 显示所有仓库，可以看到存在docker-ce的程序包yum install docker-ce ，完成 启动docker 1systemctl start docker 设置开机自启动 1systemctl enable docker 很简单镜像是运行docker容器的基础，容器运行前，必须存在对应的镜像，如果本地没有对应的镜像，docker会自动从默认仓库（DockerHub） 下载镜像,如果有本地镜像，也可以从本地仓库下载镜像获取镜像的主要方式是从共有仓库（DockerHub）下载 搜索并下载镜像（例如调用ubuntu镜像） 11.docker search ubuntu 搜索ubuntu镜像 其中列出了查找到的镜像名称、描述、星级、官方 、自动化的 12.docker pull ubuntu 下载镜像 13.docker images 查看已经下载的镜像文件 参数含义：REPOSITORY : 镜像来源于哪个仓库TAG : 镜像标签IMAGE ID : 镜像id(唯一标识镜像)CREATED : 镜像创建时间SIZE : 镜像大小，优秀的镜像往往体积小 如果不指定镜像系统版本，则会下载最新版本镜像，也可以通过指定TAG的方法来下载特定版本的镜像,在生产中不应忽略镜像标签信息或使用默认的latest标签，内容是不稳定的。 docker pull 默认从Docker Hub Registry仓库下载镜像，如果从非官方仓库下载，则需要在仓库名称前指定完整的仓库地址 例如docker pull hub.c.163.com/public/ubuntu14.04 即从网易下载 docker tag 为本地镜像任意添加新的标签14.docker tag ubuntu:latest myubuntu:latest 该命令添加的标签实际起到了类似链接的作用 15.docker inspect 获取镜像详细信息(元数据) 返回的时json格式信息，如果想要其中一项内容时，使用-f参数来指定 1docker inspect -f &#123;&#123;.RepoTag&#125;&#125; ImageID 16.docker history 查看镜像历史 镜像文件由多个层组成，docker history 可以查看镜像的创建过程 启动一个基于该ubuntu镜像的容器，并进入该容器 127.docker run -idt ubuntu /bin/bash8.docker exec -it /bin/bash -i是为了让容器能接受用户的输入，-t是指定docker为容器创建一个tty19.df -TH 查看容器文件系统的磁盘使用 保存和载入镜像 用户可以将镜像保存到本地以载入使用，或者将其复制到另外的文件系统110.docker save -o ubuntu_latest_save.tar ubuntu:latest 保存镜像 可以把保存的镜像文件载入到系统中，并载入标签等镜像文件的元数据 1211.docker load &lt; ubuntu_latest_save.tar 载入镜像12.docker load --input ubuntu_latest_save.tar 删除镜像 查询后可以看到镜像id 113.docker rmi IMAGE ID 报错为该镜像被683容器所使用，需要先删除基于这个镜像所创建的容器 docker ps -a 查询容器可以看到存在基于镜像ubuntu的容器状态为UP ，表示正在运行 114.docker stop CONTAINER ID 停止容器 115.docker rm CONTAINER ID删除该容器 116.docker rmi IMAGE ID 镜像已经删除。其中删除容器为rm 删除镜像为rmi。可以在待删除的镜像名称前面加参数-f ，强制删除。后来在DockerFile中推荐以下的命令写法 12317.docker container stop18.docker container rm19.docker images rm 创建镜像 创建镜像有三种方法，分别是基于本地模板导入镜像、基于已有镜像的容器创建镜像，基于Dockerfile 创建镜像1&gt; 基于本地模板导入镜像如果本地有镜像的模板文件，可以基于该模板创建镜像，镜像模板文件也可以从OpenVZ下载 wget http://download.openvz.org/template/precreated/ubuntu-14.04-x86_64-minimal.tar.gz 下载模板文件 下载完成后，执行以下命令，可以用该模板文件创建文件 120.cat ubuntu-14.04-x86_64-minimal.tar.gz | docker import - ubuntu-14.04_minimal_amd64 其中 docker import：从归档文件中创建镜像用法：docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]-c :应用docker 指令创建镜像；-m :提交时的说明文字； 可以看到刚刚导出的镜像，启动并运行 2&gt;基于已有的镜像容器创建镜像接上图在容器中新建一个for_new_image 目录 与原容器相比此时已经发生变化，，可以提交为新镜像 121.docker commit -m &quot;creatd new dir&quot; -a &quot;root&quot; 87acd63067e1 new_ubuntu 其中 docker commit ：从容器创建一个新的镜像。语法： docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]-a :提交的镜像作者；-c :使用Dockerfile指令来创建镜像；-m :提交时的说明文字；-p :在commit时，将容器暂停。 提交成功后会返回镜像ID，可以看到新镜像已经存在 3&gt; 基于Dockerfile 创建镜像&nbsp;&nbsp;&nbsp;&nbsp;Dockerfile 是一种被Docker程序解释的脚本，每条指令对应linux下的一条命令， Docker程序可以读取Dockerfile脚本，根据指令生成定制的镜像。Dockerfile指令分为构建指令和设置指令。构建指令用于构建镜像，不会在容器的镜像上运行；设置指令用于设置镜像属性，其操作可以在容器的镜像上执行 （1）FROM&nbsp;&nbsp;&nbsp;&nbsp;构建指令，用于指定基础镜像，必须指定，且必须在Dockerfile所有指令之前指定，因为后续指令都依赖该指令指定的镜像，，可以指定DockerHub中的镜像，也可以指定本地仓库中的 （2）MAINTAINER &nbsp;&nbsp;&nbsp;&nbsp;构建指令，用于将镜像制作者相关信息写入镜像中，当我们对该镜像执行docker inspect 命令时，会显示该字段 （3）RUN &nbsp;&nbsp;&nbsp;&nbsp;构建指令，用于执行任何被基础镜像所支持的命令，例如ubuntu基础镜像只能使用ubuntu命令，centos基础镜像只能使用centos命令 （4）CMD &nbsp;&nbsp;&nbsp;&nbsp;设置指令，用于指定容器启动时执行的操作，可以执行自定义脚本，亦可以执行系统命令，，此命令只能在Dockerfile脚本中设置一次，设置多个只会执行最后一个 （5）ENTRYPOINT （entrypoint） &nbsp;&nbsp;&nbsp;&nbsp;设置指令，用于指定容器启动时执行的命令，可以在Dockerfile脚本中设置多次，只有最后一个有效 ENTRYPOINT 使用分两种情况 ： &nbsp;&nbsp;&nbsp;&nbsp;独自使用时，如果同时使用了CMD命令，且CMD指定的是一个完整可执行命令，那么二者会互相覆盖，只有写在最后的那条指令有效；与CMD指令配合使用，CMD指令可以指定ENTRYPOINT的默认参数，此时CMD指令指定的仅仅是参数部分，而ENTRYPOINT需要使用JSON方式指定需要执行的命令但不能使用参数 （6）USER 设置指令，用于设置启动容器的用户，默认为root （7）EXPOSE &nbsp;&nbsp;&nbsp;&nbsp;设置指令，用于将容器中的端口映射称为宿主机中的摸个端口。极大方便了访问容器 。 宿主机IP：PORT &nbsp;&nbsp;&nbsp;&nbsp;需要两步操作，首先在Docerfile中使用 EXPOSE设置需要映射的容器端口号，然后在 docker run 中使用参数 -p 指定前面的端口号，该端口号就会被随机映射称为宿主机中的一个端口号，也可以指定需要映射到宿主机的哪个端口，但要注意指定的端口没有被占用。 &nbsp;&nbsp;&nbsp;&nbsp;端口映射是Docker比较重要的一个功能，因为每次运行容器时，容器IP不能被指定，而是桥接模式网卡随机生成的，但是宿主机IP地址是固定的，将容器端口映射称为宿主机上的一个端口，可以免去每次访问容器时都要查看容器IP的麻烦 &nbsp;&nbsp;&nbsp;&nbsp;一个运行中的容器，使用 ==docker port CONTAINER ID== 查看该端口号在宿主机上的映射端口 （8） ENV （environment） &nbsp;&nbsp;&nbsp;&nbsp;构建指令，用于在镜像中设置一个环境变量，设置成功后，后续的RUN 指令都可以使用该指令设置的环境 （9）ADD &nbsp;&nbsp;&nbsp;&nbsp;构建指令，用于把本地文件添加到容器，默认所有拷贝到容器中文件和文件夹权限为755（-rwxr-xr-x），UID和GID为0，如果是一个目录，那么会将该目录下的所有文件添加到容器，但不包括目录；如果文件是可识别的压缩格式，则docker会进行解压缩 （10）VOLUME&nbsp;&nbsp;&nbsp;&nbsp;设置指令， 指定挂载点，用于使容器中某个目录具有持久化存储数据的功能，该目录可以被容器本身使用，也可以共享给其他容器使用由于容器使用AUFS文件系统，不能持久化数据，容器关闭后，所有更改也会消失，因此容器有应用持久化数据存储的需求时，可以使用该指令 （11）WORKDIR&nbsp;&nbsp;&nbsp;&nbsp;设置指令，可以多次切换目录（cd），可以在RUN, CMD, ENTRYPOINT 命令前使用 (12) COPY (src)…(dest)&nbsp;&nbsp;&nbsp;&nbsp;复制本地主机 src (为Dockerfile所在目录的相对路径、文件或目标）下的内容到镜像中的 dest 下。路径不存在时会自动创建。支持正则。 下面展示一则使用Dockerfile创建Tomcat镜像的实例1234567891011121314151617181920212223242526272829303132333435363738394041#Pull base image // 获取基础镜像FROM ubuntu:latestMAINTAINER XXX# LABEL maintainer=&quot;XXX&quot;#update source //更新镜像源RUN echo &quot;deb http://cn.archive.ubuntu.com/ubuntu xenial main universe&quot;&gt;/etc/apt/sources.listRUN apt-get update#Install curl // 安装curlRUN apt-get -y install curl#Install JDK 8 //安装JDK,其中的cookie使用burpsuit获取RUN cd /tmp &amp;&amp; curl -L &apos;http://download.oracle.com/otn-pub/java/jdk/8u191-b12/2787e4a523244c269598db4e85c51e0c/jdk-8u191-linux-i586.tar.gz&apos; -H &apos;Cookie:s_fid=1CC16A1445A28C96-0DF2FFDC49166DB3; ELOQUA=GUID=25787B725D6B4A1E98D0D92A1C00A0F7; s_nr=1540978397285-Repeat; RT=&quot;sl=23&amp;ss=1540977568733&amp;tt=40261&amp;obo=21&amp;sh=1540977921638%3D23%3A2 1%3A40261%2C1540977919016%3D22%3A21%3A37654%2C1540977918989%3D21%3A20%3A3 7654%2C1540977913741%3D20%3A19%3A37654%2C1540977913712%3D19%3A18%3A37654&amp;dm=oracle.com&amp;si=6be7a975-8d66-41f3-92c8-a5748709fec8&amp;bcn=%2F%2F1288af 19.akstat.io%2F&amp;nu=http%3A%2F%2Fdownload.oracle.com%2Fotn-pub%2Fjava%2Fjdk%2F8u191-b12%2F2787e4a523244c269598db4e85c51e0c%2Fjdk-8u191-linux-i586 .tar.gz&amp;cl=1540978405737&quot;;atgRecVisitorId=127AFu33Mp_NNJQHlgn2ZpQPg5vZT6c4TietQ0-KTTWmfuc8127; gpw_e24=https%3A%2F%2Fwww.oracle.com%2Ftechnetwork %2Fjava%2Fjavase%2Fdownloads%2Fjdk8-downloads-2133151.html; s_cc=true; s_sq=%5B%5BB%5D%5D; oraclelicense=accept-securebackup-cookie&apos;|tar -zxRUN mkdir -p /usr/lib/jvmRUN mv /tmp/jdk1.8.0_191 /usr/lib/jvm/java-8-oracle/#Set Oracle JDK 8 as default Java //配置Java环境RUN update-alternatives --install /usr/bin/java java /usr/lib/jvm/java-8-oracle/bin/java 300RUN update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/java-8-oracle/bin/javac 300ENV JAVA_HOME /usr/lib/jvm/java-8-oracle/#Install Tomcat8 //安装TomcatRUN cd /tmp &amp;&amp; curl -L &apos;https://mirror.bit.edu.cn/apache/tomcat/tomcat-8/v8.5.34/bin/apache-tomcat-8.5.34.tar.gz&apos;| tar -xzRUN mv /tmp/apache-tomcat-8.5.34/ /opt/tomcat8/ENV CATALINA_HOME /opt/tomcat8ENV PATH $PATH:$CATALINA_HOME/bin#Expose ports EXPOSE 8090:8080 //设置映射端口，tomcat的8080端口映射为宿主机的8090端口#Define default command //运行tomcat，查看日志ENTRYPOINT /opt/tomcat8/bin/startup.sh &amp;&amp; tail -f /opt/tomcat8/logs/catalina.out 或 运行Dockerfile要在Dockerfile所在的目录，”./“应为Dockerfile脚本所在目录，否则就会报上下文环境的错误,MV、COPY、ADD的文件位置都是相对于/root 来说的第一遍执行(使用的第一条命令)时出现很多错误，最后修改成功了，以下截图是第二遍执行(第二条命令) 因此会报使用缓存 在下载jdk的时候，需要加上cookie，没加时出现以下报错 Java和Tomcat程序的安装包下载地址可能会发生变化，因此使用该脚本时先根据实际下载地址对其进行修改，包括解压后的生成路径也会有改变 运行镜像，启动一个基于镜像tomcat的容器，宿主机输入http://localhost:8090 即可访问tomcat]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[亲测Hexo+Github个人博客搭建]]></title>
    <url>%2F2018%2F11%2F15%2F%E4%BA%B2%E6%B5%8BHexo-Github%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装 Hexo 相当简单然而在安装前，您必须检查电脑中是否已安装下列应用程序： Node.jshttps://nodejs.org/dist/v10.13.0/node-v10.13.0-x64.msi(Winx64) Githttps://github.com/git-for-windows/git/releases/download/v2.19.1.windows.1/Git-2.19.1-64-bit.exe（Win x64） 输入 ： 123node -vnpm -vgit --version 检查Node.js 和 Git 是否 安装成功 在此处，如果Node.js 版本低，在后面的搭建过程中无法顺利执行，建议各位在官网下载最新版本；Git如果没有加入环境变量需要将Git添加到环境变量 在自己认为合适的位置创建一个个文件夹，我的是E:\Personal-blog\hexo ，在命令行界面进入该文件夹，然后使用 npm 即可完成 Hexo 的安装 1npm install -g hexo-cli 安装完成，可能会有WARN，但不会影响正常使用然后输入： 1npm install hexo --save 在这一步时，我遇到如下报错12345npm WARN deprecated titlecase@1.1.2: no longer maintainednpm ERR! Unexpected end of JSON input while parsing near &apos;...&quot;:&quot;^0.3.1&quot;,&quot;benchmark&apos;npm ERR! A complete log of this run can be found in:npm ERR! C:\Users\dell\AppData\Roaming\npm-cache\_logs\2018-11-12T15_46_56_713Z-debug.log 解决办法：更新npm源即可 1npm config set registry https://registry.npm.taobao.org Hexo安装完成，检测是否正确安装 1hexo -v Hexo的配置在当前目录下新建一个名为blog的文件夹，用于存放博客网站的信息在命令行进入blog，初始化该文件夹，并安装所需组件 12hexo init npm install 安装完成后，检测是否安装成功 1hexo g 1hexo s 根据提示访问https://localhost:4000/ 出现该界面说明Hexo在本地的配置完成了。（因为我改了配置文件，所以显示出我的名字，原位置应为Hexo） 注册GitHub账号与配置https://github.com/ 进入网站后，点击Sign up 进行注册， 填写自己的用户名，邮箱，密码（邮箱后面会用到验证账户） 注册完成后，新建代码仓库点击网页右上角”+” 中的New repo ，新建仓库 在该界面输入仓库名，描述信息，选择共有或私有仓库注意仓库名要和你的用户名一致(yourname.github.io)，否则后面会访问错误 创建完成后会自动显示你的仓库界面 点击选项栏 Setting ，向下拖至此处，将none 选项选为第一个选项，开启GitHub Pages功能 并Save，可以暂时Change theme，以供暂时访问，但是后面我们使用的是Hexo主题，两者并不冲突 一段时间后即可看到提示创建成功 那么Github一侧的配置已经全部结束了。 将GitHub Page与Hexo关联配置Git个人信息123git config --golbal user.name &quot;username&quot;git config --global user.email &quot;xxx@example.com&quot;git config --list //查看用户信息 可以看到如下信息 在合适的位置新建文件夹daemon ，进入到该文件夹中右击进入 Git Bash 1$ git init 该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干 在Git bash中 123cd ~/.ssh lscat id_rsa.pub 就可以看到你自己的公钥，复制下来，进入Github的个人设置界面 点击New Ssh Key 将密钥粘贴上，添加就可以了 1ssh -T git@github.com 成功。编辑 hexo下的blog下的_config.yml123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/CrimsonRomance/CrimsonRomance.github.io branch: master 编辑daemon.git 下的config12345678910[core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true symlinks = false ignorecase = true[branch &quot;master&quot;] remote = https://github.com/CrimsonRomance/CrimsonRomance.github.io merge = refs/heads/master 然后进入 hexo\blog ，右击进入 git bash 12hexo g // 生成hexo d // 部署 如果在 hexo d 出现下面的 错误， 1npm install --save hexo-deployer-git 安装此扩展即可 ，然后重新 hexo g ， hexo d 然后访问网站（https://youname.github.io/）即可]]></content>
      <tags>
        <tag>Hexo+GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
